[
    {
        "text": "The Microkernel architecture pattern is useful when your software system or product contains many integration points to external entities. and most importantly , you will not be able to tell exactly tell what entities will get integrated into your system in the future. The Microkernel architecture pattern can be identified as a plug-in based pattern. . Also known as the plug-in architecture pattern, it consists of two main components, the core system and plug-in components."
    },
    {
        "text": "A microkernel architecture is called a plugin architecture because of the way capabilities and functionality are added to a minimal core OS. They're an efficient way to achieve application customization and can offer software lifecycle benefits. Find out how a microkernel architecture pattern provides the best of both the monolithic and distributed microservices approach to application development and management. What is a microkernel? Microkernels arguably fall between a microservices-based architecture and a monolithic one -- a microkernel contains only the required amount of software to implement an OS. A monolithic architecture is easy to build because all the pieces are together. However, it must be tested as a single unit, which makes debugging and updates potentially painful. Microservices are the opposite. They are easy to debug, isolate and deploy, but there are many moving parts to manage. Tracking the interactions between components can be challenging. With a microkernel architecture, there is a core and plugins. The core application is centralized, like a monolith. And most additional development is done through plugins that add capabilities or modify existing functionality. Generally, these plugins do not know about each other and do not communicate with each other. However, the microkernel provides interprocess communication -- a way for the processes to talk."
    },
    {
        "text": "Pattern Description The microkernel architecture pattern consists of two types of architecture components: a core system and plug-in modules. Application logic is divided between independent plug-in modules and the basic core system, providing extensibility, flexibility, and isolation of application features and custom processing logic. Figure 3-1 illustrates the basic microkernel architecture pattern. The core system of the microkernel architecture pattern traditionally contains only the minimal functionality required to make the system operational. Many operating systems implement the microkernel architecture pattern, hence the origin of this pattern’s name. From a business-application perspective, the core system is often defined as the general business logic sans custom code for special cases, special rules, or complex conditional processing. Alt Text Figure 3-1. Microkernel architecture pattern The plug-in modules are stand-alone, independent components that contain specialized processing, additional features, and custom code that is meant to enhance or extend the core system to produce additional business capabilities. Generally, plug-in modules should be independent of other plug-in modules, but you can certainly design plug-ins that require other plug-ins to be present. Either way, it is important to keep the communication between plug-ins to a minimum to avoid dependency issues. The core system needs to know about which plug-in modules are available and how to get to them. One common way of implementing this is through some sort of plug-in registry. This registry contains information about each plug-in module, including things like its name, data contract, and remote access protocol details (depending on how the plug-in is connected to the core system). For example, a plug-in for tax software that flags high-risk tax audit items might have a registry entry that contains the name of the service (AuditChecker), the data contract (input data and output data), and the contract format (XML). It might also contain a WSDL (Web Services Definition Language) if the plug-in is accessed through SOAP. Plug-in modules can be connected to the core system through a variety of ways, including OSGi (open service gateway initiative), messaging, web services, or even direct point-to-point binding (i.e., object instantiation). The type of connection you use depends on the type of application you are building (small product or large business application) and your specific needs (e.g., single deploy or distributed deployment). The architecture pattern itself does not specify any of these implementation details, only that the plug-in modules must remain independent from one another. The contracts between the plug-in modules and the core system can range anywhere from standard contracts to custom ones. Custom contracts are typically found in situations where plug-in components are developed by a third party where you have no control over the contract used by the plug-in. In such cases, it is common to create an adapter between the plug-in contact and your standard contract so that the core system doesn’t need specialized code for each plug-in. When creating standard contracts (usually implemented through XML or a Java Map), it is important to remember to create a versioning strategy right from the start."
    }
]